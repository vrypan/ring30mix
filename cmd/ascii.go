package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/vrypan/ring30mix/rand"
)

var (
	asciiSeed        uint64
	asciiGenerations int
	asciiWidth       int
	asciiChar0       string
	asciiChar1       string
)

var asciiCmd = &cobra.Command{
	Use:   "ascii",
	Short: "Visualize RNG output as ASCII art",
	Long: `Visualize the bit patterns of random numbers generated by R30R2.

Each row shows the bits from one Read() call (32 bytes = 256 bits max).
This helps understand the bit distribution and pattern of the RNG output.

Examples:
  # Default visualization (50 outputs, full width)
  r30r2 ascii

  # Narrower view for terminals
  r30r2 ascii --width=128 --generations=100

  # ASCII characters
  r30r2 ascii --char0=" " --char1="*"

  # Different seed
  r30r2 ascii --seed=12345

  # Compact 0/1 display
  r30r2 ascii --char0="0" --char1="1"`,
	Run: func(cmd *cobra.Command, args []string) {
		visualize(asciiSeed, asciiGenerations, asciiWidth, asciiChar0, asciiChar1)
	},
}

func init() {
	asciiCmd.Flags().Uint64Var(&asciiSeed, "seed", 1, "RNG seed")
	asciiCmd.Flags().IntVar(&asciiGenerations, "generations", 50, "Number of outputs to display")
	asciiCmd.Flags().IntVar(&asciiWidth, "width", 256, "Width in bits (max 256)")
	asciiCmd.Flags().StringVar(&asciiChar0, "char0", "░", "Character for 0 bits")
	asciiCmd.Flags().StringVar(&asciiChar1, "char1", "█", "Character for 1 bits")
}

// visualize displays RNG output as ASCII art
func visualize(seed uint64, generations, width int, char0, char1 string) {
	if width < 1 || width > 256 {
		fmt.Fprintf(os.Stderr, "Error: width must be between 1 and 256\n")
		os.Exit(1)
	}

	// Create RNG
	rng := rand.New(seed)

	// Calculate bytes needed for requested width
	bytesNeeded := (width + 7) / 8
	if bytesNeeded > 32 {
		bytesNeeded = 32
	}

	// Print header
	fmt.Printf("R30R2 RNG Output Visualization\n")
	fmt.Printf("Seed: %d | Outputs: %d | Width: %d bits\n", seed, generations, width)
	fmt.Printf("Showing random output bit patterns\n")
	fmt.Println()

	// Display outputs
	buf := make([]byte, bytesNeeded)
	for gen := 0; gen < generations; gen++ {
		// Generate random bytes
		rng.Read(buf)

		// Print output number (padded)
		fmt.Printf("%4d │ ", gen)

		// Print bits from the random output
		bitsDisplayed := 0
		for byteIdx := 0; byteIdx < len(buf) && bitsDisplayed < width; byteIdx++ {
			b := buf[byteIdx]
			bitsInThisByte := 8
			if bitsDisplayed+bitsInThisByte > width {
				bitsInThisByte = width - bitsDisplayed
			}

			for bit := 0; bit < bitsInThisByte; bit++ {
				if b&1 == 1 {
					fmt.Print(char1)
				} else {
					fmt.Print(char0)
				}
				b >>= 1
			}
			bitsDisplayed += bitsInThisByte
		}
		fmt.Println()
	}

	fmt.Println()
	fmt.Printf("Displayed %d random outputs from R30R2 RNG\n", generations)
}
