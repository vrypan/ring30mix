package main

import (
	"flag"
	"fmt"
	"os"

	"github.com/vrypan/rule30rnd/rand"
)

func main() {
	var (
		seed        = flag.Uint64("seed", 1, "RNG seed")
		generations = flag.Int("generations", 50, "Number of outputs to display")
		width       = flag.Int("width", 256, "Width in bits (max 256)")
		char0       = flag.String("char0", "░", "Character for 0 bits")
		char1       = flag.String("char1", "█", "Character for 1 bits")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, `Rule 30 RNG Output Visualization

Visualizes the bit patterns of random numbers generated by Rule 30 RNG.
Each row shows the bits from one Read() call (32 bytes = 256 bits max).

Usage:
  visualize-rule30 [options]

Options:
  --seed N          RNG seed (default: 1)
  --generations N   Number of outputs to show (default: 50)
  --width N         Width in bits to display, max 256 (default: 256)
  --char0 C         Character for 0 bits (default: ░)
  --char1 C         Character for 1 bits (default: █)

Examples:
  # Default visualization (50 outputs, full width)
  visualize-rule30

  # Narrower view for terminals
  visualize-rule30 --width=128 --generations=100

  # ASCII characters
  visualize-rule30 --char0=" " --char1="*"

  # Different seed
  visualize-rule30 --seed=12345

  # Compact 0/1 display
  visualize-rule30 --char0="0" --char1="1"
`)
	}

	flag.Parse()

	if *width < 1 || *width > 256 {
		fmt.Fprintf(os.Stderr, "Error: width must be between 1 and 256\n")
		os.Exit(1)
	}

	// Create RNG
	rng := rand.New(*seed)

	// Calculate bytes needed for requested width
	bytesNeeded := (*width + 7) / 8
	if bytesNeeded > 32 {
		bytesNeeded = 32
	}

	// Print header
	fmt.Printf("Rule 30 RNG Output Visualization\n")
	fmt.Printf("Seed: %d | Outputs: %d | Width: %d bits\n", *seed, *generations, *width)
	fmt.Printf("Showing random output bit patterns\n")
	fmt.Println()

	// Display outputs
	buf := make([]byte, bytesNeeded)
	for gen := 0; gen < *generations; gen++ {
		// Generate random bytes
		rng.Read(buf)

		// Print output number (padded)
		fmt.Printf("%4d │ ", gen)

		// Print bits from the random output
		bitsDisplayed := 0
		for byteIdx := 0; byteIdx < len(buf) && bitsDisplayed < *width; byteIdx++ {
			b := buf[byteIdx]
			bitsInThisByte := 8
			if bitsDisplayed+bitsInThisByte > *width {
				bitsInThisByte = *width - bitsDisplayed
			}

			for bit := 0; bit < bitsInThisByte; bit++ {
				if b&1 == 1 {
					fmt.Print(*char1)
				} else {
					fmt.Print(*char0)
				}
				b >>= 1
			}
			bitsDisplayed += bitsInThisByte
		}
		fmt.Println()
	}

	fmt.Println()
	fmt.Printf("Displayed %d random outputs from Rule 30 RNG\n", *generations)
}
